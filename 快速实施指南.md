# 隧道代理后台管理系统 - 快速实施指南

## 立即开始（30分钟内完成基础搭建）

### 第一步：创建项目结构（5分钟）

```bash
# 在当前prox目录下执行
mkdir -p server/{models,routes,middleware,services,utils}
mkdir -p server/proxy/{config,core,middleware,utils}
mkdir -p web/{public,src/{components,views,router,store,api}}
mkdir -p scripts logs uploads ssl/{certs,keys}
```

### ✨ 最新目录结构

项目已升级为模块化架构，包含：
- **后台管理系统**: `server/` (Express + MySQL + JWT)
- **集成式前端界面**: `web/public/index.html` (Vue3 + Element Plus CDN)
- **模块化代理服务器**: `server/proxy/` (重构后的代理功能)
- **数据库脚本**: `scripts/` (已包含完整初始化)

### 🎨 前端架构特点

✅ **零构建部署**: 无需Webpack/Vite，直接运行  
✅ **CDN依赖**: Vue3 + Element Plus 通过CDN引入  
✅ **单文件应用**: 所有前端代码集成在一个HTML文件  
✅ **响应式设计**: 完美适配桌面和移动设备  
✅ **实时状态**: 自动刷新数据，状态同步显示

### 第二步：安装后端依赖（5分钟）

```bash
# 在prox根目录执行
npm install express sequelize mysql2 jsonwebtoken bcrypt cors dotenv multer

# 如果需要开发工具
npm install --save-dev nodemon
```

### 第三步：创建环境配置（2分钟）

创建 `.env` 文件：
```bash
# 数据库配置
DB_HOST=localhost
DB_PORT=3306
DB_NAME=proxy
DB_USER=root
DB_PASSWORD=123456

# 服务器配置
ADMIN_PORT=3000
PROXY_HTTP_PORT=8082
PROXY_HTTPS_PORT=8083

# JWT配置
JWT_SECRET=your_super_secret_key_here_make_it_long_and_random

# SSL配置
SSL_CERT_PATH=./ssl/certs/
SSL_KEY_PATH=./ssl/keys/
```

### 第四步：创建数据库（5分钟）

创建 `scripts/init-db.sql`：
```sql
-- 创建数据库
CREATE DATABASE IF NOT EXISTS proxy_management CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE proxy_management;

-- 管理员用户表
CREATE TABLE admin_users (
  id int PRIMARY KEY AUTO_INCREMENT,
  username varchar(50) UNIQUE NOT NULL,
  password varchar(255) NOT NULL,
  role enum('admin', 'viewer') DEFAULT 'admin',
  status enum('active', 'inactive') DEFAULT 'active',
  created_at timestamp DEFAULT CURRENT_TIMESTAMP,
  updated_at timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 代理用户表
CREATE TABLE proxy_users (
  id int PRIMARY KEY AUTO_INCREMENT,
  username varchar(50) UNIQUE NOT NULL,
  password varchar(255) NOT NULL,
  status enum('active', 'inactive') DEFAULT 'active',
  max_connections int DEFAULT 10,
  expire_date datetime,
  created_at timestamp DEFAULT CURRENT_TIMESTAMP,
  updated_at timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 代理服务器表
CREATE TABLE proxy_servers (
  id int PRIMARY KEY AUTO_INCREMENT,
  name varchar(100) NOT NULL,
  http_port int NOT NULL,
  https_port int,
  domain varchar(255),
  ssl_enabled boolean DEFAULT false,
  status enum('running', 'stopped') DEFAULT 'stopped',
  created_at timestamp DEFAULT CURRENT_TIMESTAMP,
  updated_at timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- SSL证书表
CREATE TABLE ssl_certificates (
  id int PRIMARY KEY AUTO_INCREMENT,
  name varchar(100) NOT NULL,
  domain varchar(255) NOT NULL,
  cert_path varchar(500),
  key_path varchar(500),
  expire_date datetime,
  status enum('active', 'expired') DEFAULT 'active',
  created_at timestamp DEFAULT CURRENT_TIMESTAMP,
  updated_at timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 连接日志表
CREATE TABLE connection_logs (
  id bigint PRIMARY KEY AUTO_INCREMENT,
  proxy_user_id int,
  client_ip varchar(45),
  target_host varchar(255),
  bytes_sent bigint DEFAULT 0,
  bytes_received bigint DEFAULT 0,
  status enum('success', 'failed') DEFAULT 'success',
  created_at timestamp DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (proxy_user_id) REFERENCES proxy_users(id)
);

-- 插入默认管理员账号（密码：admin123）
INSERT INTO admin_users (username, password, role) VALUES 
('admin', '$2b$10$rQ8QWVgwKpCZqw.dJj7V8eG.ZJ9wKq1XKXqGHk4Vs9c0cNz0c9V8G', 'admin');

-- 插入测试代理用户
INSERT INTO proxy_users (username, password, max_connections) VALUES 
('test_user', '$2b$10$rQ8QWVgwKpCZqw.dJj7V8eG.ZJ9wKq1XKXqGHk4Vs9c0cNz0c9V8G', 10);

-- 插入默认代理服务器配置
INSERT INTO proxy_servers (name, http_port, https_port, domain) VALUES 
('默认代理服务器', 8082, 8083, 'pox.aipor.cc');
```

执行数据库初始化：
```bash
mysql -u root -p < scripts/init-db.sql
```

### 第五步：创建基础后端代码（10分钟）

创建 `server/app.js`：
```javascript
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const path = require('path');

const app = express();
const PORT = process.env.ADMIN_PORT || 3000;

// 中间件
app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname, '../web/dist')));

// 基础路由
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', message: '后台管理系统运行正常' });
});

// 导入路由
const authRoutes = require('./routes/auth');
const userRoutes = require('./routes/users');
const proxyRoutes = require('./routes/proxy');

app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/proxy', proxyRoutes);

// 前端路由支持
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../web/dist/index.html'));
});

// 启动服务器
app.listen(PORT, () => {
  console.log(`🚀 后台管理系统启动成功！`);
  console.log(`📍 管理界面: http://localhost:${PORT}`);
  console.log(`🔗 API地址: http://localhost:${PORT}/api`);
});

module.exports = app;
```

创建 `server/models/index.js`：
```javascript
const { Sequelize } = require('sequelize');

const sequelize = new Sequelize({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  database: process.env.DB_NAME,
  username: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  dialect: 'mysql',
  logging: false
});

// 测试数据库连接
sequelize.authenticate()
  .then(() => {
    console.log('✅ 数据库连接成功');
  })
  .catch(err => {
    console.error('❌ 数据库连接失败:', err);
  });

module.exports = sequelize;
```

创建 `server/routes/auth.js`：
```javascript
const express = require('express');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const sequelize = require('../models');

const router = express.Router();

// 登录接口
router.post('/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // 查询用户
    const [results] = await sequelize.query(
      'SELECT * FROM admin_users WHERE username = ? AND status = "active"',
      { replacements: [username] }
    );
    
    if (results.length === 0) {
      return res.status(401).json({ error: '用户名或密码错误' });
    }
    
    const user = results[0];
    
    // 验证密码
    const isValid = await bcrypt.compare(password, user.password);
    if (!isValid) {
      return res.status(401).json({ error: '用户名或密码错误' });
    }
    
    // 生成Token
    const token = jwt.sign(
      { id: user.id, username: user.username, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    // 更新最后登录时间
    await sequelize.query(
      'UPDATE admin_users SET updated_at = NOW() WHERE id = ?',
      { replacements: [user.id] }
    );
    
    res.json({
      success: true,
      token,
      user: {
        id: user.id,
        username: user.username,
        role: user.role
      }
    });
  } catch (error) {
    console.error('登录错误:', error);
    res.status(500).json({ error: '登录失败' });
  }
});

module.exports = router;
```

创建 `server/routes/users.js`：
```javascript
const express = require('express');
const bcrypt = require('bcrypt');
const sequelize = require('../models');

const router = express.Router();

// 获取代理用户列表
router.get('/', async (req, res) => {
  try {
    const [results] = await sequelize.query(
      'SELECT id, username, status, max_connections, expire_date, created_at FROM proxy_users ORDER BY created_at DESC'
    );
    res.json({ success: true, data: results });
  } catch (error) {
    res.status(500).json({ error: '获取用户列表失败' });
  }
});

// 创建代理用户
router.post('/', async (req, res) => {
  try {
    const { username, password, max_connections = 10, expire_date } = req.body;
    
    // 密码加密
    const hashedPassword = await bcrypt.hash(password, 10);
    
    await sequelize.query(
      'INSERT INTO proxy_users (username, password, max_connections, expire_date) VALUES (?, ?, ?, ?)',
      { replacements: [username, hashedPassword, max_connections, expire_date] }
    );
    
    res.json({ success: true, message: '用户创建成功' });
  } catch (error) {
    if (error.parent?.code === 'ER_DUP_ENTRY') {
      res.status(400).json({ error: '用户名已存在' });
    } else {
      res.status(500).json({ error: '创建用户失败' });
    }
  }
});

// 更新代理用户
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { username, password, max_connections, expire_date, status } = req.body;
    
    let query = 'UPDATE proxy_users SET username = ?, max_connections = ?, expire_date = ?, status = ?';
    let params = [username, max_connections, expire_date, status];
    
    if (password) {
      const hashedPassword = await bcrypt.hash(password, 10);
      query += ', password = ?';
      params.push(hashedPassword);
    }
    
    query += ' WHERE id = ?';
    params.push(id);
    
    await sequelize.query(query, { replacements: params });
    res.json({ success: true, message: '用户更新成功' });
  } catch (error) {
    res.status(500).json({ error: '更新用户失败' });
  }
});

// 删除代理用户
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await sequelize.query('DELETE FROM proxy_users WHERE id = ?', { replacements: [id] });
    res.json({ success: true, message: '用户删除成功' });
  } catch (error) {
    res.status(500).json({ error: '删除用户失败' });
  }
});

module.exports = router;
```

创建 `server/routes/proxy.js`：
```javascript
const express = require('express');
const sequelize = require('../models');

const router = express.Router();

// 获取代理服务器列表
router.get('/servers', async (req, res) => {
  try {
    const [results] = await sequelize.query('SELECT * FROM proxy_servers ORDER BY created_at DESC');
    res.json({ success: true, data: results });
  } catch (error) {
    res.status(500).json({ error: '获取服务器列表失败' });
  }
});

// 获取实时统计
router.get('/stats', async (req, res) => {
  try {
    // 获取用户总数
    const [userCount] = await sequelize.query('SELECT COUNT(*) as count FROM proxy_users WHERE status = "active"');
    
    // 获取今日连接数
    const [todayConnections] = await sequelize.query(
      'SELECT COUNT(*) as count FROM connection_logs WHERE DATE(created_at) = CURDATE()'
    );
    
    // 获取在线服务器数
    const [runningServers] = await sequelize.query('SELECT COUNT(*) as count FROM proxy_servers WHERE status = "running"');
    
    res.json({
      success: true,
      data: {
        activeUsers: userCount[0].count,
        todayConnections: todayConnections[0].count,
        runningServers: runningServers[0].count,
        systemStatus: 'running'
      }
    });
  } catch (error) {
    res.status(500).json({ error: '获取统计信息失败' });
  }
});

module.exports = router;
```

### 第六步：更新package.json（2分钟）

更新 `package.json` 添加启动脚本：
```json
{
  "name": "lpl-proxy",
  "version": "1.0.0",
  "description": "隧道代理服务器 - 带后台管理",
  "main": "server/app.js",
  "scripts": {
    "start": "node server/app.js",
    "dev": "nodemon server/app.js",
    "tunnel": "node tunnel-proxy.js"
  },
  "dependencies": {
    "dotenv": "^16.5.0",
    "express": "^4.18.2",
    "sequelize": "^6.35.0",
    "mysql2": "^3.6.5",
    "jsonwebtoken": "^9.0.2",
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "multer": "^1.4.5-lts.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
```

### 第七步：测试后端（1分钟）

```bash
# 启动后端服务
npm run dev
```

测试API：
```bash
# 测试健康检查
curl http://localhost:3000/api/health

# 测试登录（用户名：admin，密码：admin123）
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"admin123"}'

# 测试获取用户列表
curl http://localhost:3000/api/users
```

## 🎨 集成式前端界面（已完成）

### 前端特性概览

我们的前端采用**集成式架构**，具有以下特点：

✅ **完整功能界面**: 登录、仪表盘、用户管理、服务器管理、日志查看  
✅ **零构建部署**: 通过CDN引入Vue3 + Element Plus，无需编译  
✅ **响应式设计**: 完美适配桌面和移动设备  
✅ **实时数据**: 自动刷新统计数据和服务器状态  
✅ **JWT认证**: 完整的前后端分离认证机制  

### 前端界面预览

**🏠 仪表盘页面**:
- 实时统计卡片 (用户数、连接数、服务器状态)
- 服务器状态监控
- 系统运行时间显示

**👥 用户管理页面**:
- 用户列表表格 (分页、搜索)
- 添加/编辑/删除用户功能
- 用户状态和连接数限制管理

**🖥️ 服务器管理页面**:
- 服务器配置列表
- 一键启动/停止服务器
- 实时状态显示 (运行中/已停止 + 进程ID)

**📊 日志查看页面**:
- 连接日志查询和过滤
- 实时日志更新
- 用户行为追踪

### 访问界面

启动后台管理系统后，直接访问：
```
http://localhost:3000
```

默认登录账号：`admin` / `admin123`

## 下一步计划

### 立即可以做的事情：
1. ✅ 基础后端已完成
2. ✅ 数据库结构已创建
3. ✅ 基础API已可用
4. 🔄 可以通过API测试用户管理功能

### 接下来的开发：
1. **集成现有代理服务**：修改 `tunnel-proxy.js` 使其从数据库读取用户认证
2. **完善前端界面**：创建Vue.js管理界面
3. **SSL证书管理**：实现证书上传和管理功能
4. **监控功能**：添加实时监控和统计

### 测试默认账号：
- **管理员账号**：admin / admin123
- **测试代理用户**：test_user / admin123

## 🚀 最新功能 - 模块化代理服务器

### 已完成功能：
✅ **完整的后台管理系统** (Express + MySQL + JWT)  
✅ **前端管理界面** (Vue3 + Element Plus 单页应用)  
✅ **模块化代理服务器** (重构后的代理架构)  
✅ **状态同步管理** (API控制代理服务器启停)  
✅ **用户认证集成** (数据库认证 + 连接限制)  
✅ **连接日志记录** (会话跟踪 + 详细日志)  

### 启动系统：

```bash
# 1. 启动后台管理系统
npm run dev

# 2. 通过API启动代理服务器
curl -X POST http://localhost:3000/api/proxy/servers/1/start \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json"

# 3. 测试代理功能
curl -x http://test_user:admin123@localhost:8082 -s http://httpbin.org/ip
```

### 管理界面：
- **访问地址**: http://localhost:3000
- **功能模块**: 仪表盘、用户管理、服务器管理、日志查看
- **状态监控**: 实时显示代理服务器运行状态和连接统计

### 代理服务器特性：
- **模块化架构**: 配置、核心、中间件、工具分离
- **数据库认证**: 完全集成MySQL用户验证
- **连接跟踪**: IP和用户连接数限制
- **会话管理**: 每个连接的生命周期跟踪
- **优雅关闭**: 支持SIGTERM/SIGINT信号处理
- **状态同步**: 管理API与代理进程状态实时同步

现在您已经有了一个完整的**企业级隧道代理管理系统**！🎉 